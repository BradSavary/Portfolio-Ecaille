# Copilot Instructions - Habit Tracker App

## üì± Contexte du projet
Vous travaillez sur **Habit Tracker**, une application web mobile-first d√©velopp√©e avec **Next.js** pour aider les utilisateurs √† cr√©er, suivre et analyser leurs habitudes quotidiennes.

## üéØ Objectifs principaux
- Offrir une exp√©rience simple, motivante et personnalisable
- Aider √† construire de bonnes routines
- Interface optimis√©e pour mobile en priorit√© (responsive design)
- Exp√©rience utilisateur fluide et intuitive

---

## üèóÔ∏è Stack technique

### Framework & Core
- **Framework**: Next.js 15.5.6 (TypeScript 5.x)
- **React**: 19.1.0 + React DOM 19.1.0
- **Build Tool**: Turbopack (Next.js int√©gr√©)
- **Package Manager**: npm

### Styling & UI
- **CSS Framework**: Tailwind CSS v4 (avec @tailwindcss/postcss)
- **Syst√®me de design**: shadcn/ui (composants Radix UI)
- **Ic√¥nes**: Lucide React 0.546.0
- **Th√®mes**: next-themes 0.4.6 (dark/light mode)
- **Utility**: 
  - clsx 2.1.1 (conditional classes)
  - tailwind-merge 3.3.1 (merge classes)
  - class-variance-authority 0.7.1 (variants)

### Formulaires & Validation
- **Forms**: React Hook Form 7.65.0
- **Validation**: Zod 4.1.12
- **Resolvers**: @hookform/resolvers 5.2.2

### UI Components (Radix UI)
- **Avatar**: @radix-ui/react-avatar 1.1.10
- **Dialog**: @radix-ui/react-dialog 1.1.15
- **Label**: @radix-ui/react-label 2.1.7
- **Progress**: @radix-ui/react-progress 1.1.7
- **Slot**: @radix-ui/react-slot 1.2.3
- **Switch**: @radix-ui/react-switch 1.2.6
- **Tabs**: @radix-ui/react-tabs 1.1.13
- **Sheet**: Composant de panneau lat√©ral (menu mobile, sidebars)

### Utilities & Libraries
- **Date**: date-fns 4.1.0
- **Calendar**: react-day-picker 9.11.1
- **Notifications**: sonner 2.0.7

### Development & Quality
- **Linting**: ESLint 9.x + eslint-config-next 15.5.6
- **TypeScript**: 5.x (Strict mode activ√©)
- **Dev Tools**: Next.js Dev Tools + Turbopack

### Base de donn√©es & ORM
- **BDD**: PostgreSQL (Neon sur Vercel)
- **ORM**: Prisma 6.19.0 (@prisma/client 6.19.0)
- **Config**: dotenv 17.2.3 pour variables d'environnement
- **Migrations**: Prisma Migrate
- **Client singleton**: `/lib/prisma.ts` pour r√©utilisation globale

---

## üé® Design System & Guidelines

### Tokens s√©mantiques (OBLIGATOIRE)
> **Syst√®me bas√© sur l'analyse de la DA** du dossier `/inspiration` avec support complet dark/light mode

- **R√àGLE ABSOLUE** : Utiliser exclusivement les tokens s√©mantiques pour toutes les couleurs
- **Interdiction formelle** : Classes Tailwind directes (`bg-white`, `text-black`, `bg-gray-100`, etc.)
- **Documentation compl√®te** : `/docs/DESIGN_TOKENS.md`
- **Helpers TypeScript** : `/lib/design-tokens.ts`

#### Background tokens (5 niveaux d'√©l√©vation)
- `bg-background-100` : Main app background (blanc cass√©/noir profond)
- `bg-background-200` : Subtle background (conteneur principal)
- `bg-background-300` : Cards elevated (blanc pur/gris fonc√© pour cards)
- `bg-background-400` : Hover states (interactions l√©g√®res)
- `bg-background-500` : Borders & dividers (s√©parateurs)

#### Foreground tokens (9 niveaux typographiques)
- `text-foreground-100` : Disabled text (d√©sactiv√©)
- `text-foreground-200` : Placeholder text (champs vides)
- `text-foreground-300` : Secondary text (descriptions, labels)
- `text-foreground-400` : Tertiary text (m√©tadonn√©es, dates)
- `text-foreground-500` : Body text (paragraphes standard)
- `text-foreground-600` : Subheadings (sous-titres)
- `text-foreground-700` : Headings (titres H2, H3)
- `text-foreground-800` : Primary text (titres H1, texte important)
- `text-foreground-900` : High contrast (maximum contraste)

#### Accent colors (Cat√©gories d'habitudes)
Couleurs vibrantes pour diff√©rencier les types d'habitudes. Utiliser avec `var(--accent-*)`.

- **Purple** (`accent-purple`) : Sant√©/Bien-√™tre
- **Blue** (`accent-blue`) : Productivit√©
- **Green** (`accent-green`) : Sport/Nature
- **Orange** (`accent-orange`) : Cr√©ativit√©
- **Pink** (`accent-pink`) : Social/Relationnel
- **Teal** (`accent-teal`) : Apprentissage

Chaque couleur a une variante `-light` pour les backgrounds :
```tsx
// Exemple d'utilisation
<Badge className="bg-[var(--accent-purple)] text-background-100">
  Sant√©
</Badge>
<Card className="bg-[var(--accent-purple-light)]">
  Contenu avec fond color√© l√©ger
</Card>
```

**Helpers disponibles** :
```tsx
import { getHabitColorClass, HABIT_COLORS } from '@/lib/design-tokens'

// R√©cup√©rer les classes CSS
const bgClass = getHabitColorClass('purple', 'solid') // ou 'light'
```

#### Status colors (Feedback & √âtats)
Pour les feedbacks utilisateur et √©tats de l'application :

- **Success** (`success` / `success-light`) : Habitude compl√©t√©e, streak maintenu
- **Warning** (`warning` / `warning-light`) : Streak en danger, attention n√©cessaire
- **Error** (`error` / `error-light`) : Habitude manqu√©e, erreur
- **Info** (`info` / `info-light`) : Tips, suggestions, informations

**Helpers disponibles** :
```tsx
import { getStatusColorClass, STATUS_COLORS } from '@/lib/design-tokens'

// R√©cup√©rer les classes selon le variant
const bgClass = getStatusColorClass('success', 'light')
const textClass = getStatusColorClass('success', 'text')
const borderClass = getStatusColorClass('success', 'border')
```

### Composants UI (shadcn/ui PRIORIT√â ABSOLUE)
- **Principe** : Toujours utiliser shadcn/ui avant toute autre solution
- **Composants install√©s** : Button, Input, Card, Dialog, Form, Badge, Progress, Calendar, Switch, Tabs, Toast (Sonner), Avatar, Sheet
- **Personnalisation** : Via variants et CSS variables uniquement
- **Accessibilit√©** : Int√©gr√©e par d√©faut dans tous les composants

Si besoin install√© d'autre composants Radix UI via shadcn/ui.

### Patterns de navigation responsive
**Navigation mobile avec menu burger** : Pattern standard pour l'approche mobile-first

#### Structure recommand√©e
```typescript
'use client' // N√©cessaire pour useState + event handlers

export function ResponsiveNav() {
  const [isOpen, setIsOpen] = useState(false)
  
  return (
    <nav>
      {/* Desktop: Navigation visible */}
      <div className="hidden md:flex">
        {/* Liens de navigation */}
      </div>
      
      {/* Mobile: Menu burger avec Sheet */}
      <div className="md:hidden">
        <Sheet open={isOpen} onOpenChange={setIsOpen}>
          <SheetTrigger asChild>
            <Button variant="ghost" size="icon">
              <Menu className="h-6 w-6" />
            </Button>
          </SheetTrigger>
          <SheetContent side="right">
            {/* Contenu du menu mobile */}
            <Link onClick={() => setIsOpen(false)}>...</Link>
          </SheetContent>
        </Sheet>
      </div>
    </nav>
  )
}
```

#### Bonnes pratiques navigation
- **Composant Sheet** : Utiliser pour menus mobiles (panneau lat√©ral)
- **Breakpoint standard** : `md:` (768px) pour basculer desktop/mobile
- **Fermeture auto** : `onClick={() => setIsOpen(false)}` sur les liens
- **Accessibilit√©** : 
  - `<span className="sr-only">` pour texte lecteurs d'√©cran
  - `asChild` sur SheetTrigger pour √©viter nested buttons
- **Ic√¥nes** : Menu (burger), X (fermeture) de Lucide React
- **Justification 'use client'** : Menu n√©cessite `useState` pour g√©rer l'√©tat ouvert/ferm√© + `onClick` handlers

#### Exemple complet (LandingNav)
```typescript
'use client' // ‚úÖ Justifi√© : useState + onClick handlers

import { useState } from "react"
import { Menu } from "lucide-react"
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet"

export function LandingNav() {
  const [isOpen, setIsOpen] = useState(false) // √âtat du menu
  
  return (
    <nav className="bg-background-200 border-b border-background-500">
      {/* Logo toujours visible */}
      <div className="flex items-center justify-between">
        <Logo />
        
        {/* Desktop: boutons visibles */}
        <div className="hidden md:flex gap-4">
          <Button>Se connecter</Button>
        </div>
        
        {/* Mobile: burger menu */}
        <div className="md:hidden">
          <Sheet open={isOpen} onOpenChange={setIsOpen}>
            <SheetTrigger asChild>
              <Button variant="ghost" size="icon">
                <Menu className="h-6 w-6" />
                <span className="sr-only">Ouvrir le menu</span>
              </Button>
            </SheetTrigger>
            <SheetContent side="right" className="bg-background-200">
              <div className="flex flex-col gap-4">
                <Link onClick={() => setIsOpen(false)}>
                  <Button className="w-full">Se connecter</Button>
                </Link>
              </div>
            </SheetContent>
          </Sheet>
        </div>
      </div>
    </nav>
  )
}
```

---

## üì± Approche d√©veloppement

### Mobile-First (OBLIGATOIRE)
- Conception mobile d'abord (320px+)
- Breakpoints responsive : mobile (320px), tablet (768px), desktop (1024px)
- Interactions tactiles optimis√©es
- Performance mobile prioritaire

### Architecture des pages
```
/ - Landing page / connexion rapide
/login - Connexion utilisateur  
/register - Inscription utilisateur
/dashboard - Vue principale (stats, liste d'habitudes)
/habits/[id] - D√©tail d'une habitude
/account - Profil et r√©glages
```

---

## üèÜ Roadmap de d√©veloppement

### Version 1 - MVP (Priorit√© absolue)
1. **Authentification** : NextAuth.js - Inscription/connexion/session/protection routes
2. **Gestion habitudes** : CRUD habitudes avec fr√©quences et validation
3. **Dashboard** : Vue calendrier + liste du jour
4. **Streaks** : Suivi des s√©ries de r√©ussite

### Version 2 - Am√©liorations
- Personnalisation (ic√¥nes, couleurs, cat√©gories)
- Mode sombre/clair (next-themes)
- Page d√©tail habitude
- Export donn√©es

### Version 3 - Avanc√©
- Notifications intelligentes
- Statistiques avanc√©es
- Graphiques de progression

---

## üß© Guidelines techniques

### Conventions de code
- **TypeScript** : Mode strict activ√©
- **Composants** : React fonctionnels avec hooks uniquement
- **Nommage** : camelCase (JS/TS), kebab-case (CSS)
- **Structure** : Modulaire et r√©utilisable
- **Documentation** : Commentaires pour logique complexe

### Architecture Client/Server Components (CRITIQUE)
> **R√àGLE FONDAMENTALE** : Chaque choix entre Client et Server Component doit √™tre **justifi√© et justifiable logiquement**.

#### üñ•Ô∏è Server Components (par d√©faut)
**Utiliser TOUJOURS par d√©faut**, sauf si besoin explicite d'interactivit√© client.

**Quand utiliser** :
- ‚úÖ R√©cup√©ration de donn√©es depuis la BDD (Prisma)
- ‚úÖ Acc√®s aux secrets/variables serveur
- ‚úÖ Composants purement statiques (sans interactivit√©)
- ‚úÖ Op√©rations lourdes c√¥t√© serveur
- ‚úÖ R√©duction du bundle JavaScript client

**Exemples justifi√©s** :
```typescript
// ‚úÖ Server Component - R√©cup√®re des donn√©es
export default async function HabitsList({ userId }: { userId: string }) {
  const habits = await prisma.habit.findMany({ where: { userId } })
  return <div>{habits.map(h => <HabitCard key={h.id} habit={h} />)}</div>
}

// ‚úÖ Server Component - Layout statique
export default function DashboardLayout({ children }: { children: React.ReactNode }) {
  return <div className="container">{children}</div>
}
```

#### üíª Client Components ('use client')
**Utiliser UNIQUEMENT quand n√©cessaire** - Doit √™tre justifiable.

**Quand utiliser** :
- ‚úÖ Hooks React (useState, useEffect, useContext, etc.)
- ‚úÖ Event handlers (onClick, onChange, onSubmit, etc.)
- ‚úÖ Interactions utilisateur (hover, focus, animations)
- ‚úÖ APIs navigateur (localStorage, window, document)
- ‚úÖ Composants shadcn/ui avec interactivit√© (Dialog, Form, Switch, etc.)

**Exemples justifi√©s** :
```typescript
// ‚úÖ Client Component - Utilise useState + onClick
'use client'
export function HabitToggle({ habitId }: { habitId: string }) {
  const [completed, setCompleted] = useState(false)
  
  const handleToggle = async () => {
    // Logique d'interaction
    setCompleted(!completed)
  }
  
  return <button onClick={handleToggle}>Toggle</button>
}

// ‚úÖ Client Component - Formulaire avec validation
'use client'
export function CreateHabitForm() {
  const form = useForm() // Hook React Hook Form
  return <form onSubmit={form.handleSubmit(onSubmit)}>...</form>
}
```

#### üîÄ Pattern de composition recommand√©
**Maximiser Server, minimiser Client** - Encapsuler le client dans le serveur.

```typescript
// ‚úÖ EXCELLENT - Server Component parent
export default async function HabitsPage() {
  const habits = await getHabits() // Fetch c√¥t√© serveur
  
  return (
    <div>
      <HabitsHeader /> {/* Server Component */}
      <HabitsList habits={habits}> {/* Server Component */}
        {habits.map(habit => (
          <HabitCard key={habit.id} habit={habit}> {/* Server */}
            <HabitToggleButton habitId={habit.id} /> {/* Client uniquement ici */}
          </HabitCard>
        ))}
      </HabitsList>
    </div>
  )
}
```

#### ‚ö†Ô∏è Erreurs courantes √† √©viter
```typescript
// ‚ùå MAUVAIS - Tout en Client alors que pas n√©cessaire
'use client'
export default function Dashboard() { // Pas de hooks = pas besoin de client
  return <div>Static content</div>
}

// ‚ùå MAUVAIS - Fetch dans Client Component
'use client'
export function HabitsList() {
  const [habits, setHabits] = useState([])
  useEffect(() => {
    fetch('/api/habits').then(r => r.json()).then(setHabits) // ‚ùå
  }, [])
}

// ‚úÖ BON - Fetch dans Server Component
export default async function HabitsList() {
  const habits = await prisma.habit.findMany() // ‚úÖ
  return <div>{habits.map(...)}</div>
}
```

#### üìã Checklist de d√©cision

Avant de choisir Client Component, v√©rifier :
1. ‚ùì Ai-je besoin de hooks React ? ‚Üí Oui = Client
2. ‚ùì Ai-je besoin d'event handlers ? ‚Üí Oui = Client
3. ‚ùì Ai-je besoin d'APIs navigateur ? ‚Üí Oui = Client
4. ‚ùì Le composant est-il purement statique ? ‚Üí Oui = Server
5. ‚ùì Puis-je isoler l'interactivit√© dans un sous-composant ? ‚Üí Oui = Faire √ßa

#### üéØ R√®gles d'or
- **Par d√©faut = Server** : Ne pas ajouter 'use client' sans raison
- **Justification obligatoire** : Tout Client Component doit avoir une raison document√©e
- **Granularit√©** : Client Components aussi petits que possible
- **Composition** : Server parent ‚Üí Client enfant isol√©
- **Performance** : Moins de JavaScript client = app plus rapide

### Structure des Skeletons (‚úÖ COMPL√àTE)
```
components/Skeletons/
‚îú‚îÄ‚îÄ index.ts                      # Export central de tous les skeletons
‚îú‚îÄ‚îÄ base/                         # Atomiques r√©utilisables
‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ SkeletonCard.tsx         # Carte de base avec emoji + texte + action
‚îÇ   ‚îú‚îÄ‚îÄ SkeletonText.tsx         # Lignes de texte (param√©trable)
‚îÇ   ‚îú‚îÄ‚îÄ SkeletonStat.tsx         # Statistique (nombre + label)
‚îÇ   ‚îú‚îÄ‚îÄ SkeletonButton.tsx       # Bouton avec variants (default, outline, ghost)
‚îÇ   ‚îî‚îÄ‚îÄ SkeletonAvatar.tsx       # Avatar circulaire (sm, md, lg, xl)
‚îú‚îÄ‚îÄ composed/                     # Composants m√©tier compos√©s
‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ SkeletonHabitCard.tsx    # HabitCard avec variants (daily, weekly, monthly)
‚îÇ   ‚îú‚îÄ‚îÄ SkeletonStatCard.tsx     # Carte de stats avec header + grid de stats
‚îÇ   ‚îú‚îÄ‚îÄ SkeletonMoodCalendar.tsx # Calendrier d'humeur mensuel complet
‚îÇ   ‚îî‚îÄ‚îÄ SkeletonProgressionTimeline.tsx # Timeline verticale de progression
‚îî‚îÄ‚îÄ pages/                        # Pages compl√®tes
    ‚îú‚îÄ‚îÄ index.ts
    ‚îú‚îÄ‚îÄ SkeletonDashboard.tsx    # Dashboard avec header + stats + habitudes
    ‚îú‚îÄ‚îÄ SkeletonProfile.tsx      # Profil avec level card + habitudes par fr√©quence
    ‚îú‚îÄ‚îÄ SkeletonMoodPage.tsx     # Page mood avec calendrier + stats
    ‚îú‚îÄ‚îÄ SkeletonProgression.tsx  # Progression avec header sticky + timeline
    ‚îî‚îÄ‚îÄ SkeletonHabitDetail.tsx  # D√©tail habitude avec header + stats + historique
```

**Usage recommand√©** :
```tsx
// Dans un loading.tsx (Next.js App Router)
import { SkeletonDashboard } from '@/components/Skeletons'

export default function DashboardLoading() {
  return <SkeletonDashboard />
}

// Dans un composant avec √©tat de chargement
import { SkeletonHabitCard } from '@/components/Skeletons'

{isLoading ? (
  <SkeletonHabitCard variant="weekly" />
) : (
  <HabitCard habit={habit} />
)}
```

**Principes de conception** :
- Utiliser les tokens s√©mantiques (`bg-background-300`, `text-foreground-400`)
- Respecter les espacements et proportions des composants r√©els
- Variants multiples pour s'adapter aux diff√©rents cas d'usage
- Composabilit√© : les skeletons de page utilisent les skeletons compos√©s

### Bonnes pratiques
- **Performance** : SSR, optimisation images, lazy loading
- **Accessibilit√©** : a11y pour tous les utilisateurs
- **Progressive Web App** : PWA compatible
- **Loading states** : Feedback utilisateur constant
- **Gestion erreurs** : Gracieuse avec Toast (Sonner) notifications
- **SEO** : Meta tags dynamiques, sitemaps
- **Respect de nextjs** : Suivre les conventions et optimisations recommand√©es par la documentation officielle pour cette version

---

## üîí S√©curit√© & Architecture

### Authentification
- **NextAuth.js** : Sessions s√©curis√©es
- **Protection routes** : Middleware pour pages priv√©es
- **Validation** : Client ET serveur (Zod)
- **Isolation donn√©es** : Par utilisateur

### Standards qualit√©
- **ESLint** : Configuration Next.js stricte
- **TypeScript** : Types stricts, pas de `any`
- **Performance** : Core Web Vitals optimis√©s
- **Tests** : √Ä impl√©menter (Jest + Testing Library)

---

## üí° Rappels critiques

### ‚úÖ √Ä TOUJOURS faire
- Tester sur mobile en premier
- Utiliser shadcn/ui exclusivement
- Appliquer les tokens s√©mantiques pour toutes les couleurs
- **Justifier chaque choix Client/Server Component**
- **Privil√©gier Server Components par d√©faut**
- Suivre les priorit√©s MVP
- Optimiser pour les interactions tactiles
- Maintenir l'interface simple et motivante
- Documenter le code
- Respecter les conventions Next.js

### ‚ùå √Ä JAMAIS faire
- Utiliser des classes de couleur Tailwind directes
- Impl√©menter des composants UI custom sans v√©rifier shadcn/ui
- **Ajouter 'use client' sans justification logique claire**
- **Faire du fetching de donn√©es dans des Client Components**
- **Mettre tout en Client Component par paresse**
- Ignorer l'approche mobile-first
- Ajouter des fonctionnalit√©s avanc√©es avant le MVP
- Utiliser `any` en TypeScript

---

## üìö Inspiration design
- **Simplicit√©** : Streaks app (motivation par s√©ries)
- **Productivit√©** : Habitify app (suivi d√©taill√©)
- **Interface** : √âpur√©e, motivante, indicateurs visuels clairs

---

## ÔøΩ Fonctionnalit√©s sp√©cifiques impl√©ment√©es

### üé≠ Mood Tracker (Suivi d'humeur)
> Calendrier mensuel permettant aux utilisateurs d'enregistrer leur humeur quotidienne avec des emojis.

#### Architecture des fichiers
```
app/mood/
‚îî‚îÄ‚îÄ page.tsx              # Server Component - Fetch moods du mois
components/mood/
‚îî‚îÄ‚îÄ MoodContent.tsx       # Client Component - Calendrier interactif
lib/actions/
‚îî‚îÄ‚îÄ mood.ts              # Server Actions - CRUD moods
prisma/schema.prisma
‚îî‚îÄ‚îÄ MoodEntry            # Mod√®le: id, userId, emoji, date, notes
```

#### R√®gles UX critiques
**R√àGLE ABSOLUE** : Seul le jour actuel peut √™tre modifi√©.

1. **Indicateurs visuels obligatoires** :
   - **Jour actuel** : Bordure primaire (`border-primary/50`), num√©ro en gras et color√©
   - **Jours avec mood pass√©s/futurs** : Opacit√© 70%, emoji non cliquable
   - **Jours sans mood pass√©s/futurs** : Fond gris√© (`bg-muted/30`), opacit√© 50%
   - **L√©gende explicative** : Bandeau informatif en haut du calendrier

2. **Interactions** :
   - ‚úÖ **Jour actuel sans mood** : Bouton `+` cliquable ‚Üí ouvre Drawer
   - ‚úÖ **Jour actuel avec mood** : Emoji cliquable ‚Üí ouvre Drawer (modification)
   - ‚ùå **Jours pass√©s/futurs** : Non cliquables (div statique)
   - ‚úÖ **Hover effects** : Uniquement sur le jour actuel

3. **Accessibilit√©** :
   - `aria-label` : "Ajouter une humeur" vs "Modifier l'humeur du jour"
   - `DrawerDescription` : Obligatoire pour √©viter warnings accessibilit√©
   - Titre dynamique : "Comment te sens-tu ?" vs "Modifier ton humeur"

4. **Feedback utilisateur** :
   - Toast diff√©renci√© : "Humeur enregistr√©e" vs "Humeur modifi√©e"
   - Emojis avec font moderne : `"Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji"`
   - Warning aria-hidden automatiquement g√©r√© par Drawer

#### Exemple de code conforme
```tsx
'use client' // Justifi√© : useState (drawer), useTransition (server actions)

export function MoodContent({ userId, initialMoods }: MoodContentProps) {
  const [isDrawerOpen, setIsDrawerOpen] = useState(false)
  const [selectedDate, setSelectedDate] = useState<Date | null>(null)
  
  const handleAddMood = (date: Date) => {
    // ‚úÖ V√©rification stricte : seulement aujourd'hui
    if (isToday(date)) {
      setSelectedDate(date)
      setIsDrawerOpen(true)
    }
  }
  
  return (
    <div>
      {/* ‚úÖ L√©gende obligatoire */}
      <div className="p-3 bg-muted/30 rounded-lg border border-muted">
        <p className="text-xs text-muted-foreground text-center">
          Seul le jour actuel (surlign√©) peut √™tre modifi√©. Les autres jours sont gris√©s.
        </p>
      </div>
      
      {/* Calendrier avec indicateurs visuels */}
      <div className={`${
        isTodayDate
          ? 'bg-card border-primary/50'       // ‚úÖ Jour actuel
          : mood
          ? 'bg-card opacity-70'              // ‚úÖ Jour pass√© avec mood
          : 'bg-muted/30 opacity-50'          // ‚úÖ Jour pass√© sans mood
      }`}>
        {mood && isTodayDate ? (
          // ‚úÖ Emoji cliquable aujourd'hui
          <button onClick={() => handleAddMood(date)} aria-label="Modifier l'humeur du jour">
            {mood.emoji}
          </button>
        ) : mood ? (
          // ‚úÖ Emoji non cliquable (pass√©/futur)
          <div>{mood.emoji}</div>
        ) : isTodayDate ? (
          // ‚úÖ Bouton + aujourd'hui
          <button onClick={() => handleAddMood(date)} aria-label="Ajouter une humeur">
            <Plus />
          </button>
        ) : (
          // ‚úÖ Cercle vide gris√© (non cliquable)
          <div className="border border-muted/50" />
        )}
      </div>
      
      {/* ‚úÖ Drawer avec Description obligatoire */}
      <Drawer open={isDrawerOpen} onOpenChange={setIsDrawerOpen}>
        <DrawerContent>
          <DrawerHeader>
            <DrawerTitle>
              {selectedDate && getMoodForDate(selectedDate)
                ? 'Modifier ton humeur'
                : 'Comment te sens-tu ?'}
            </DrawerTitle>
            <DrawerDescription>
              {selectedDate && getMoodForDate(selectedDate)
                ? 'Choisis un nouvel emoji pour modifier ton humeur du jour'
                : 'S√©lectionne l\'emoji qui correspond le mieux √† ton humeur du jour'}
            </DrawerDescription>
          </DrawerHeader>
          {/* S√©lection emojis */}
        </DrawerContent>
      </Drawer>
    </div>
  )
}
```

#### Checklist validation Mood Tracker
Avant de consid√©rer une impl√©mentation compl√®te :
- [ ] Jour actuel clairement identifiable (bordure + couleur)
- [ ] Jours pass√©s/futurs visuellement gris√©s (opacit√©)
- [ ] L√©gende informative affich√©e
- [ ] Seul le jour actuel est cliquable
- [ ] Emoji du jour actuel reste modifiable apr√®s ajout
- [ ] DrawerDescription pr√©sente (pas de warning)
- [ ] aria-label diff√©renci√©s (ajouter vs modifier)
- [ ] Toast messages contextuels (enregistr√© vs modifi√©)
- [ ] Emojis avec font moderne
- [ ] Pas de warnings aria-hidden

### üèÉ Habit Cards (Affichage adaptatif des habitudes)

#### Fr√©quences support√©es
**3 variantes obligatoires** : Daily, Weekly, Monthly

1. **DailyHabitCard** :
   - Checkmark de compl√©tion
   - Streak counter (üî• X jours)
   - Double-tap pour toggle compl√©tion
   
2. **WeeklyHabitCard** :
   - Grille 7 jours (L, M, M, J, V, S, D) ‚ö†Ô∏è **Dimanche en DERNIER**
   - Progression visuelle (X/7 jours compl√©t√©s)
   - Indicateur jour actuel
   
3. **MonthlyHabitCard** :
   - Barre de progression (X/N compl√©tions)
   - Nombre de fois r√©alis√© ce mois

#### R√®gles de jours de la semaine
**R√àGLE CRITIQUE** : Les jours de la semaine DOIVENT √™tre affich√©s dans l'ordre europ√©en.

```tsx
// ‚úÖ CORRECT - Ordre europ√©en (lundi = premier jour)
const WEEK_DAYS_FR = ['L', 'M', 'M', 'J', 'V', 'S', 'D']
// Index 0 = Lundi, Index 6 = Dimanche

// ‚ùå INCORRECT - Ordre am√©ricain
const WRONG_ORDER = ['D', 'L', 'M', 'M', 'J', 'V', 'S'] // ‚ùå

// ‚úÖ Mapping depuis Date.getDay() (0 = dimanche)
const dayLabels = ['L','M','M','J','V','S','D']
const displayLabel = dayLabels[(date.getDay() + 6) % 7] // Conversion JS ‚Üí europ√©en
```

#### Interactions utilisateur
- **Cursor pointer** : Tous les √©l√©ments cliquables doivent avoir `cursor-pointer`
- **Hover effects** : Feedback visuel sur hover (scale, background, border)
- **S√©lections multiples** : Utiliser des boutons avec √©tat s√©lectionn√© (pas de dropdowns)

#### Exemple WeeklyHabitCard conforme
```tsx
export function WeeklyHabitCard({ habit, completions }: Props) {
  const weekDays = [0, 1, 2, 3, 4, 5, 6] // Lundi √† Dimanche
  const LABELS = ['L','M','M','J','V','S','D'] // ‚úÖ Ordre europ√©en
  
  return (
    <Card>
      {/* Grille 7 jours */}
      <div className="grid grid-cols-7 gap-1">
        {weekDays.map((day, index) => {
          const isCompleted = completions.includes(day)
          const isToday = isCurrentDay(day)
          
          return (
            <div key={day} className={`${isToday ? 'border-primary' : ''}`}>
              <span>{LABELS[index]}</span> {/* ‚úÖ Index direct */}
              {isCompleted && <Check />}
            </div>
          )
        })}
      </div>
      <Progress value={completedCount} max={7} />
    </Card>
  )
}
```

### üé® Formulaires & S√©lections

#### Pattern boutons s√©lectionnables (OBLIGATOIRE)
**INTERDICTION** : Utiliser des dropdowns/selects pour des choix fr√©quents.

**Cas d'usage** : Couleurs, cat√©gories, fr√©quences, jours de la semaine.

```tsx
'use client' // Justifi√© : useState pour s√©lection

export function CreateHabitForm() {
  const [selectedColor, setSelectedColor] = useState('purple')
  const [selectedDays, setSelectedDays] = useState<number[]>([])
  
  const COLORS = ['purple', 'blue', 'green', 'orange', 'pink', 'teal']
  const DAYS = [
    { value: 0, label: 'L' },
    { value: 1, label: 'M' },
    { value: 2, label: 'M' },
    { value: 3, label: 'J' },
    { value: 4, label: 'V' },
    { value: 5, label: 'S' },
    { value: 6, label: 'D' },
  ]
  
  return (
    <form>
      {/* ‚úÖ Couleurs : grille de boutons */}
      <div className="grid grid-cols-6 gap-2">
        {COLORS.map(color => (
          <button
            type="button"
            onClick={() => setSelectedColor(color)}
            className={`h-12 rounded-lg border-2 cursor-pointer transition-all ${
              selectedColor === color
                ? 'border-primary scale-105'  // ‚úÖ √âtat s√©lectionn√©
                : 'border-muted hover:border-primary/50'
            }`}
            style={{ backgroundColor: `var(--accent-${color})` }}
          />
        ))}
      </div>
      
      {/* ‚úÖ Jours : boutons toggle */}
      <div className="flex gap-2">
        {DAYS.map(day => (
          <button
            type="button"
            onClick={() => {
              setSelectedDays(prev =>
                prev.includes(day.value)
                  ? prev.filter(d => d !== day.value)
                  : [...prev, day.value]
              )
            }}
            className={`px-4 py-2 rounded-full border cursor-pointer transition-colors ${
              selectedDays.includes(day.value)
                ? 'bg-primary text-primary-foreground border-primary'
                : 'border-muted hover:border-primary'
            }`}
          >
            {day.label}
          </button>
        ))}
      </div>
    </form>
  )
}
```

#### R√®gles de formulaires
1. **React Hook Form** : Obligatoire pour tous les formulaires
2. **Validation Zod** : Client ET serveur
3. **Feedback instantan√©** : Erreurs sous les champs
4. **Loading states** : Bouton disabled pendant soumission
5. **Toast notifications** : Succ√®s/erreur apr√®s soumission
6. **Cursor pointer** : Tous les boutons et √©l√©ments cliquables

### ÔøΩüîÑ Navigation & Next.js 15

#### Params dynamiques (CRITIQUE)
**R√àGLE NEXT.JS 15** : Les params de routes dynamiques DOIVENT √™tre await√©s.

```tsx
// ‚ùå INCORRECT - Warning Next.js 15
export default async function HabitDetailPage({
  params,
}: {
  params: { id: string }
}) {
  const result = await getHabitById(params.id) // ‚ùå Warning
}

// ‚úÖ CORRECT - Params comme Promise
export default async function HabitDetailPage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params // ‚úÖ Await obligatoire
  const result = await getHabitById(id)
}
```

#### Bottom Navigation mobile
**Pattern standard** : Navigation fix√©e en bas de l'√©cran.

```tsx
'use client' // Justifi√© : usePathname pour √©tat actif

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function BottomNav() {
  const pathname = usePathname()
  
  const NAV_ITEMS = [
    { href: '/dashboard', icon: Home, label: 'Home' },
    { href: '/mood', icon: Smile, label: 'Mood' },
    { href: '/stats', icon: TrendingUp, label: 'Stats' },
    { href: '/profile', icon: User, label: 'Profil' },
  ]
  
  return (
    <nav className="fixed bottom-0 left-0 right-0 bg-background-200 border-t border-background-500 pb-safe">
      <div className="flex justify-around items-center h-16">
        {NAV_ITEMS.map(item => {
          const isActive = pathname === item.href
          const Icon = item.icon
          
          return (
            <Link
              key={item.href}
              href={item.href}
              className={`flex flex-col items-center gap-1 cursor-pointer transition-colors ${
                isActive
                  ? 'text-primary'
                  : 'text-muted-foreground hover:text-foreground-500'
              }`}
            >
              <Icon className="h-5 w-5" />
              <span className="text-xs">{item.label}</span>
            </Link>
          )
        })}
      </div>
    </nav>
  )
}
```

### üé® Emojis & Polices modernes

#### Police emoji obligatoire
**R√àGLE** : Tous les emojis DOIVENT utiliser les polices natives modernes.

```tsx
// ‚úÖ Style obligatoire pour tous les emojis
<span style={{
  fontFamily: '"Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif'
}}>
  {emoji}
</span>

// ‚úÖ Ou via className Tailwind (si configur√©)
<span className="font-emoji">
  {emoji}
</span>
```

#### EmojiPickerDrawer
**Composant standard** pour s√©lection d'emojis.

```tsx
'use client' // Justifi√© : useState + emoji-picker-react (client-only)

import EmojiPicker from 'emoji-picker-react'
import { Drawer, DrawerContent, DrawerDescription } from '@/components/ui/drawer'

export function EmojiPickerDrawer({ selectedEmoji, onEmojiSelect }: Props) {
  const [isOpen, setIsOpen] = useState(false)
  
  return (
    <Drawer open={isOpen} onOpenChange={setIsOpen}>
      <DrawerTrigger asChild>
        <Button
          type="button"
          variant="outline"
          className="text-6xl cursor-pointer"
          style={{ fontFamily: '"Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif' }}
        >
          {selectedEmoji}
        </Button>
      </DrawerTrigger>
      <DrawerContent>
        <DrawerHeader>
          <DrawerTitle>Choisissez un emoji</DrawerTitle>
          <DrawerDescription>
            S√©lectionnez un emoji pour repr√©senter votre habitude
          </DrawerDescription>
        </DrawerHeader>
        <EmojiPicker onEmojiClick={(emojiData) => {
          onEmojiSelect(emojiData.emoji)
          setIsOpen(false)
        }} />
      </DrawerContent>
    </Drawer>
  )
}
```

---

## üîÑ Fonctionnalit√©s r√©centes impl√©ment√©es

### ‚úÖ Tri des habitudes sur le dashboard
- Les habitudes **non compl√©t√©es** apparaissent **en premier**
- Les habitudes **compl√©t√©es** sont automatiquement d√©plac√©es **en fin de liste**
- Impl√©ment√© dans `groupHabits()` dans `/lib/habits-utils.ts`
- Utilise `isCompletedToday()` pour d√©terminer l'ordre

### ‚úÖ √âdition d'habitudes
- Nouvelle page `/habits/[id]/edit` pour modifier une habitude existante
- Composant `EditHabitForm` dans `/components/habits/EditHabitForm.tsx`
- R√©utilise la m√™me structure que `CreateHabitForm`
- Bouton "Modifier" actif sur la page de d√©tail d'une habitude
- Tous les champs sont √©ditables : nom, emoji, couleur, cat√©gorie, fr√©quence, jours, objectif mensuel

### ‚úÖ Interactions tactiles sur HabitCard
**Double-clic / Double-tap** : Valider ou invalider une habitude directement
**Clic sur le cercle** : Toggle l'√©tat de compl√©tion (checkmark)
**Simple clic sur la carte** : Ouvrir la page de d√©tail de l'habitude

**Impl√©mentation** :
```tsx
// DailyHabitCard
const handleCircleClick = (e: React.MouseEvent) => {
  e.stopPropagation() // Emp√™cher l'ouverture de la page d√©tail
  if (isLoading) return // Ne pas permettre de cliquer pendant le chargement
  onToggleComplete()
}

// WeeklyHabitCard & MonthlyHabitCard - Timeout pattern pour double-clic fiable
const [clickTimeout, setClickTimeout] = useState<NodeJS.Timeout | null>(null)

const handleCardClick = (e: React.MouseEvent) => {
  e.stopPropagation()
  
  if (isLoading) return // Ne pas permettre de cliquer pendant le chargement
  
  if (clickTimeout) {
    // Double-clic d√©tect√© (< 300ms)
    clearTimeout(clickTimeout)
    setClickTimeout(null)
    onToggleComplete()
  } else {
    // Premier clic, attendre le double-clic potentiel
    const timeout = setTimeout(() => {
      setClickTimeout(null)
      onOpen()
    }, 300)
    setClickTimeout(timeout)
  }
}
```

**Avantages** :
- Gain de temps pour les utilisateurs r√©guliers
- Moins de navigation n√©cessaire
- Exp√©rience mobile optimis√©e
- Feedback visuel imm√©diat (animation du checkmark + spinner pendant chargement)

### ‚úÖ Indicateurs de chargement sur validation
**Probl√®me r√©solu** : Feedback visuel manquant lors de la validation d'habitudes

**Impl√©mentation** :
- **DashboardContent** : √âtat `loadingHabitId` pour tracker l'habitude en cours de validation
- **DailyHabitCard** : Spinner anim√© (`Loader2`) remplace le checkmark dans le cercle pendant le chargement
- **WeeklyHabitCard & MonthlyHabitCard** : Petit spinner (3x3) √† c√¥t√© du pourcentage de progression
- **D√©sactivation des clics** : Curseur `cursor-wait` et blocage des interactions pendant le chargement

```tsx
// DashboardContent
const [loadingHabitId, setLoadingHabitId] = useState<string | null>(null)

const handleToggleComplete = async (habitId: string, habitName: string) => {
  setLoadingHabitId(habitId)
  startTransition(async () => {
    const result = await toggleHabitCompletion(habitId, userId)
    setLoadingHabitId(null) // Toujours retirer le loading apr√®s la r√©ponse
    // ... toasts
  })
}

// Passage √† HabitCard
<HabitCard
  habit={habit}
  isLoading={loadingHabitId === habit.id}
  onToggleComplete={...}
  onOpen={...}
/>
```

### ‚úÖ Flexibilit√© des habitudes (Date de fin & Configuration avanc√©e)
**Nouveaux champs Prisma** : `endDate`, `weeklyGoal`, `monthDays`

#### 1. Date de fin (√©ch√©ance)
**Usage** : Habitudes temporaires avec objectif dat√© (ex: "Courir 3x/semaine jusqu'au 31 d√©cembre")

**Impl√©mentation** :
- Champ optionnel `endDate` (DateTime) dans le mod√®le Habit
- S√©lecteur de date avec Calendar (shadcn/ui) + Popover
- D√©sactivation des dates pass√©es : `disabled={(date) => date < new Date()}`
- Bouton pour retirer la date de fin si d√©finie
- Affichage dans HabitDetailContent : "Se termine le: [date format√©e]"

```tsx
// CreateHabitForm / EditHabitForm
<Popover>
  <PopoverTrigger asChild>
    <Button variant="outline">
      <CalendarIcon className="mr-2 h-4 w-4" />
      {endDate ? format(endDate, 'PPP', { locale: fr }) : 'S√©lectionner une date'}
    </Button>
  </PopoverTrigger>
  <PopoverContent>
    <Calendar
      mode="single"
      selected={endDate}
      onSelect={(date) => setValue('endDate', date)}
      disabled={(date) => date < new Date()}
      initialFocus
    />
  </PopoverContent>
</Popover>
```

#### 2. Habitudes hebdomadaires flexibles
**Deux modes** : Nombre de fois OU Jours sp√©cifiques

**Mode A : Nombre de fois par semaine** (`weeklyGoal`)
- Exemple : "3 fois par semaine" (n'importe quels jours)
- Champ `weeklyGoal` (Int 1-7)
- Validation : l'utilisateur doit compl√©ter N fois dans la semaine, jours libres
- Affichage : "3x/semaine"

**Mode B : Jours sp√©cifiques** (`weekDays`)
- Exemple : "Lundi, Mercredi, Vendredi"
- Champ `weekDays` (Json: [1, 3, 5])
- Validation : l'utilisateur doit compl√©ter les jours pr√©cis
- Affichage : "Lun, Mer, Ven"

**UI Pattern** :
```tsx
// √âtat pour basculer entre les deux modes
const [useSpecificWeekDays, setUseSpecificWeekDays] = useState(false)

// Bouton toggle
<Button onClick={() => {
  setUseSpecificWeekDays(!useSpecificWeekDays)
  if (!useSpecificWeekDays) setValue('weeklyGoal', undefined)
  else { setValue('weekDays', undefined); setSelectedDays([]) }
}}>
  {useSpecificWeekDays 
    ? '‚Üê Utiliser un nombre de fois par semaine' 
    : 'Sp√©cifier les jours pr√©cis ‚Üí'}
</Button>

// Affichage conditionnel
{!useSpecificWeekDays && <Input {...register('weeklyGoal')} />}
{useSpecificWeekDays && <DaysSelector />}
```

#### 3. Habitudes mensuelles flexibles
**Deux configurations** : Nombre libre OU Jours sp√©cifiques du mois

**Configuration obligatoire** : `monthlyGoal` (Int 1-31)
- Toujours requis : "Combien de fois par mois ?"
- Exemple : "20 fois par mois"

**Configuration optionnelle** : `monthDays` (Json: [4, 12, 25])
- Exemple : "Les 4, 12 et 25 du mois"
- S√©lection multi-jours (1-31)
- **Warning automatique** : Jours > 28 non disponibles pour f√©vrier
- Grille 7 colonnes pour s√©lection visuelle

```tsx
// Warning pour jours > 28
{selectedMonthDays.some(d => d > 28) && (
  <p className="text-sm text-[var(--warning)] bg-background-200 p-2 rounded">
    ‚ö†Ô∏è Attention : Les jours > 28 ne seront pas disponibles pour les mois courts (ex: f√©vrier)
  </p>
)}

// Grille de s√©lection des jours
<div className="grid grid-cols-7 gap-2">
  {Array.from({ length: 31 }, (_, i) => i + 1).map((day) => (
    <button onClick={() => toggleMonthDay(day)}>
      {day}
    </button>
  ))}
</div>
```

#### Validation c√¥t√© serveur
**Schema Zod mis √† jour** (`lib/actions/habits.ts`) :

```typescript
const habitSchema = z.object({
  // ... champs existants
  endDate: z.date().optional(),
  weekDays: z.array(z.number().min(0).max(6)).optional(), // Jours sp√©cifiques
  weeklyGoal: z.number().min(1).max(7).optional(), // Nombre de fois/semaine
  monthlyGoal: z.number().min(1).max(31).optional(),
  monthDays: z.array(z.number().min(1).max(31)).optional(), // Jours sp√©cifiques du mois
})
```

#### Migration Prisma appliqu√©e
```prisma
model Habit {
  // ... champs existants
  weekDays    Json?     // Pour weekly: [0,1,2,3,4,5,6] - jours sp√©cifiques
  weeklyGoal  Int?      // Pour weekly: nombre de fois par semaine (si weekDays non sp√©cifi√©)
  monthlyGoal Int?      // Pour monthly: nombre de fois dans le mois
  monthDays   Json?     // Pour monthly: [4, 12, 25] - jours sp√©cifiques du mois (1-31)
  endDate     DateTime? // Date de fin / √©ch√©ance de l'habitude
}
```

**Migration** : `20251121105441_add_habit_flexibility`

#### R√®gles de gestion
1. **Hebdomadaire** :
   - Si `weekDays` d√©fini ‚Üí validation sur jours pr√©cis
   - Si `weeklyGoal` d√©fini ‚Üí validation sur nombre de compl√©tions (jours libres)
   - Jamais les deux en m√™me temps

2. **Mensuel** :
   - `monthlyGoal` toujours requis (nombre de fois)
   - `monthDays` optionnel (jours sp√©cifiques)
   - Si `monthDays` d√©fini ‚Üí doit compl√©ter ces jours pr√©cis
   - Jours 29-31 ignor√©s pour les mois courts

3. **Date de fin** :
   - Optionnelle pour toutes les fr√©quences
   - D√©sactive l'habitude apr√®s la date
   - Affichage dans la page de d√©tail

---

## ÔøΩ Organisation du Dashboard (Syst√®me de Tabs) - D√âCEMBRE 2024

### Architecture des onglets
**R√àGLE** : Le dashboard est organis√© en **3 onglets** avec syst√®me de tabs (shadcn/ui).

#### Ordre des onglets (OBLIGATOIRE)
1. **Aujourd'hui** (onglet par d√©faut)
2. **Compl√©t√©es** (avec 2 sous-sections)
3. **Autres**

#### Onglet 1 : "Aujourd'hui"
**Description affich√©e** : _"Habitudes √† faire aujourd'hui"_

**Contenu** :
- Habitudes **non compl√©t√©es** aujourd'hui
- Pr√©vues pour aujourd'hui selon leur fr√©quence et configuration
- Tri√©es : non compl√©t√©es en premier

#### Onglet 2 : "Compl√©t√©es" (avec 2 sous-sections)
**Description affich√©e** : _"Habitudes compl√©t√©es √† 100% sur leur p√©riode"_

**Sous-section A : "Aujourd'hui"**
- **Quotidiennes** compl√©t√©es aujourd'hui
- **Hebdo/Mensuel** compl√©t√©es **au moins 1 fois** aujourd'hui (peu importe le % d'objectif)
- ‚ö†Ô∏è **Comportement important** : D√®s qu'une habitude hebdo/mensuel est compl√©t√©e 1 fois aujourd'hui, elle **quitte "Aujourd'hui"** et va dans **"Compl√©t√©es > Aujourd'hui"**

**Sous-section B : "Compl√©t√©es pr√©c√©demment"**
- **Hebdo/Mensuel** compl√©t√©es **hier ou avant** (mais **PAS aujourd'hui**)
- **Les quotidiennes n'apparaissent JAMAIS ici**
- Reste visible jusqu'√† r√©initialisation (d√©but de semaine/mois)

#### Onglet 3 : "Autres"
**Description affich√©e** : _"Habitudes non pr√©vues pour aujourd'hui"_

**Contenu** :
- Habitudes hebdomadaires avec jours sp√©cifiques (aujourd'hui n'est pas un jour pr√©vu)
- Habitudes mensuelles avec jours sp√©cifiques (aujourd'hui n'est pas un jour pr√©vu)

### Logique de filtrage (lib/habits-utils.ts)

#### Fonction isFullyCompletedToday()
```typescript
/**
 * V√©rifier si compl√©t√©e aujourd'hui (peu importe le pourcentage)
 * Pour TOUTES les fr√©quences : retourne true si au moins 1 compl√©tion aujourd'hui
 */
export function isFullyCompletedToday(habit: HabitWithCompletions, today: Date): boolean {
  return isCompletedToday(habit, today) // Simple : au moins 1 compl√©tion aujourd'hui
}
```

#### Fonction isFullyCompletedPreviously()
```typescript
/**
 * V√©rifier si compl√©t√©e hier ou avant (mais pas aujourd'hui)
 * Retourne TOUJOURS false pour les quotidiennes
 */
export function isFullyCompletedPreviously(habit: HabitWithCompletions, today: Date): boolean {
  // Les habitudes quotidiennes ne peuvent JAMAIS √™tre dans cette cat√©gorie
  if (habit.frequency === 'daily') return false
  
  const todayStart = new Date(today)
  todayStart.setHours(0, 0, 0, 0)
  
  // V√©rifier s'il y a des compl√©tions avant aujourd'hui
  const hasCompletionsBefore = habit.completions.some((c) => {
    const completionDate = new Date(c.completedAt)
    completionDate.setHours(0, 0, 0, 0)
    return completionDate.getTime() < todayStart.getTime()
  })
  
  if (!hasCompletionsBefore) return false
  
  // Si compl√©t√©e aujourd'hui, elle ne doit PAS √™tre dans "pr√©c√©demment"
  if (isCompletedToday(habit, today)) return false
  
  return true
}
```

#### Fonction groupHabits()
```typescript
export function groupHabits(habits: HabitWithCompletions[], today: Date) {
  // 1. Identifier habitudes compl√©t√©es aujourd'hui (quotidiennes + hebdo/mensuel)
  const completedToday = habits.filter((habit) => isFullyCompletedToday(habit, today))
  
  // 2. Identifier habitudes compl√©t√©es pr√©c√©demment (hebdo/mensuel uniquement)
  const completedPreviously = habits.filter((habit) => isFullyCompletedPreviously(habit, today))
  
  // 3. Habitudes restantes (exclure toutes les compl√©t√©es)
  const remainingHabits = habits.filter((habit) => 
    !isFullyCompletedToday(habit, today) && 
    !isFullyCompletedPreviously(habit, today)
  )
  
  // 4. S√©parer "Aujourd'hui" et "Autres"
  const todayHabitsUnsorted = remainingHabits.filter((habit) => shouldShowToday(habit, today))
  const otherHabits = remainingHabits.filter((habit) => !shouldShowToday(habit, today))
  
  // 5. Trier "Aujourd'hui" : non compl√©t√©es en premier
  const todayHabits = todayHabitsUnsorted.sort((a, b) => {
    const aCompleted = isCompletedToday(a, today)
    const bCompleted = isCompletedToday(b, today)
    return aCompleted ? 1 : -1
  })
  
  return { todayHabits, otherHabits, completedToday, completedPreviously }
}
```

### Exemples concrets

#### Exemple 1 : Habitude hebdomadaire (weeklyGoal=5)
- **Lundi 08:00** : Compl√©t√©e 1/5 ‚Üí Va dans **"Compl√©t√©es > Aujourd'hui"** (quitte "Aujourd'hui")
- **Mardi 10:00** : Pas compl√©t√©e aujourd'hui, mais 1/5 hier ‚Üí Dans **"Aujourd'hui"** (objectif non atteint)
- **Mercredi 14:00** : Compl√©t√©e 2/5 ‚Üí Va dans **"Compl√©t√©es > Aujourd'hui"**
- **Jeudi 09:00** : Pas compl√©t√©e aujourd'hui, compl√©t√©e hier ‚Üí **"Compl√©t√©es > Pr√©c√©demment"** (compl√©t√©e avant mais pas ajd)
- **Vendredi 11:00** : Compl√©t√©e 5/5 (100%) ‚Üí Va dans **"Compl√©t√©es > Aujourd'hui"**
- **Samedi 15:00** : Objectif atteint, pas compl√©t√©e ajd ‚Üí **"Compl√©t√©es > Pr√©c√©demment"**

#### Exemple 2 : Habitude quotidienne
- **Lundi** : Pas compl√©t√©e ‚Üí **"Aujourd'hui"**
- **Mardi** : Compl√©t√©e ‚Üí **"Compl√©t√©es > Aujourd'hui"**
- **Mercredi** : Pas compl√©t√©e ‚Üí **"Aujourd'hui"**
- **JAMAIS** dans **"Compl√©t√©es > Pr√©c√©demment"** (quotidiennes exclues)

#### Exemple 3 : Habitude hebdomadaire (jours pr√©cis : Lun, Mer, Ven)
- **Lundi 10:00** : Compl√©t√©e ‚Üí **"Compl√©t√©es > Aujourd'hui"**
- **Mardi** : Pas pr√©vue ‚Üí **"Autres"**
- **Mercredi 14:00** : Pas compl√©t√©e, jour pr√©vu ‚Üí **"Aujourd'hui"**
- **Jeudi** : Pas pr√©vue, mais compl√©t√©e hier ‚Üí **"Compl√©t√©es > Pr√©c√©demment"**

### Interface utilisateur (DashboardContent.tsx)

```tsx
'use client'

export function DashboardContent({ 
  todayHabits, 
  otherHabits, 
  completedToday, 
  completedPreviously, 
  userId 
}: Props) {
  // Empty state global si aucune habitude
  if (todayHabits.length === 0 && otherHabits.length === 0 && 
      completedToday.length === 0 && completedPreviously.length === 0) {
    return <EmptyState message="Cr√©ez votre premi√®re habitude pour commencer !" />
  }
  
  return (
    <Tabs defaultValue="today" className="w-full">
      <TabsList className="grid w-full grid-cols-3 mb-6">
        <TabsTrigger value="today">Aujourd'hui</TabsTrigger>
        <TabsTrigger value="completed">Compl√©t√©es</TabsTrigger>
        <TabsTrigger value="others">Autres</TabsTrigger>
      </TabsList>
      
      {/* ONGLET 1 : AUJOURD'HUI */}
      <TabsContent value="today" className="mt-0">
        <p className="text-sm text-foreground-400 mb-4 text-center">
          Habitudes √† faire aujourd'hui
        </p>
        {renderHabitsList(todayHabits)}
      </TabsContent>
      
      {/* ONGLET 2 : COMPL√âT√âES (avec sous-sections) */}
      <TabsContent value="completed" className="mt-0">
        <p className="text-sm text-foreground-400 mb-4 text-center">
          Habitudes compl√©t√©es √† 100% sur leur p√©riode
        </p>
        
        {/* Sous-section A : Aujourd'hui */}
        {completedToday.length > 0 && (
          <div className="mb-6">
            <h3 className="text-lg font-semibold text-foreground-700 mb-3">
              Aujourd'hui
            </h3>
            {renderHabitsList(completedToday)}
          </div>
        )}
        
        {/* Sous-section B : Pr√©c√©demment */}
        {completedPreviously.length > 0 && (
          <div className="mb-6">
            <h3 className="text-lg font-semibold text-foreground-700 mb-3">
              Compl√©t√©es pr√©c√©demment
            </h3>
            {renderHabitsList(completedPreviously)}
          </div>
        )}
        
        {/* Empty state si aucune habitude compl√©t√©e */}
        {completedToday.length === 0 && completedPreviously.length === 0 && (
          <EmptyState message="Les habitudes compl√©t√©es appara√Ætront ici." />
        )}
      </TabsContent>
      
      {/* ONGLET 3 : AUTRES */}
      <TabsContent value="others" className="mt-0">
        <p className="text-sm text-foreground-400 mb-4 text-center">
          Habitudes non pr√©vues pour aujourd'hui
        </p>
        {renderHabitsList(otherHabits)}
      </TabsContent>
    </Tabs>
  )
}
```

### Checklist Dashboard
- [ ] 3 onglets dans l'ordre : Aujourd'hui, Compl√©t√©es, Autres
- [ ] "Aujourd'hui" par d√©faut
- [ ] Descriptions sous chaque onglet
- [ ] Sous-sections "Aujourd'hui" et "Pr√©c√©demment" dans Compl√©t√©es
- [ ] Quotidiennes JAMAIS dans "Pr√©c√©demment"
- [ ] Hebdo/Mensuel compl√©t√©es 1x ajd ‚Üí "Compl√©t√©es > Aujourd'hui"
- [ ] Empty states personnalis√©s
- [ ] Tri : non compl√©t√©es en premier

---

## üé® Refactorisation formulaire de cr√©ation - D√âCEMBRE 2024

### Organisation en 3 sections Cards

#### Section 1 : "Identit√© de l'habitude"
```tsx
<Card className="border-2">
  <CardHeader>
    <CardTitle className="flex items-center gap-2">
      <span className="text-2xl">{selectedEmoji}</span>
      Identit√© de l'habitude
    </CardTitle>
    <CardDescription>
      Donnez un nom, un emoji et une couleur √† votre habitude
    </CardDescription>
  </CardHeader>
  <CardContent className="space-y-4">
    {/* Nom */}
    <Label className="text-base font-semibold">Nom *</Label>
    <Input placeholder="Ex: M√©diter 10 minutes" />
    
    {/* Emoji + Couleur (grid 2 colonnes) */}
    <div className="grid md:grid-cols-2 gap-4">
      <EmojiPickerDrawer />
      <ColorGrid /> {/* 6 couleurs */}
    </div>
    
    {/* Cat√©gories SANS emojis (grid 2x4) */}
    <Label className="text-base font-semibold">Cat√©gorie *</Label>
    <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
      {CATEGORIES.map((cat) => (
        <button>{cat}</button> {/* Texte simple, PAS d'emoji */}
      ))}
    </div>
  </CardContent>
</Card>
```

#### Section 2 : "Fr√©quence et r√©currence"
**Boutons de fr√©quence simplifi√©s** (R√àGLE) :
```tsx
{/* ‚úÖ CORRECT - Simple et lisible */}
<div className="grid grid-cols-3 gap-2">
  <button className="py-4 px-2">Quotidienne</button>
  <button className="py-4 px-2">Hebdomadaire</button>
  <button className="py-4 px-2">Mensuelle</button>
</div>

{/* ‚ùå INCORRECT - Trop charg√© */}
<button>
  <span className="font-bold">Quotidienne</span>
  <span className="text-xs">Tous les jours</span> {/* ‚ùå */}
</button>
```

**Messages d'aide contextuels** (OBLIGATOIRE) :
```tsx
<div className="flex items-start gap-2 bg-background-200 p-3 rounded-lg">
  <Info className="h-5 w-5 text-[var(--accent-blue)] flex-shrink-0" />
  <div className="text-sm text-foreground-600">
    Choisissez un <strong>nombre de fois par semaine</strong> ou des <strong>jours pr√©cis</strong>.
  </div>
</div>
```

#### Section 3 : "Options avanc√©es" (Accordion)
```tsx
<Accordion type="single" collapsible>
  <AccordionItem value="advanced" className="border-2 rounded-lg px-4 bg-background-200">
    <AccordionTrigger className="text-base font-semibold">
      Options avanc√©es (facultatif)
    </AccordionTrigger>
    <AccordionContent className="space-y-4 pt-4">
      {/* Description + Date de fin */}
    </AccordionContent>
  </AccordionItem>
</Accordion>
```

### R√®gles de hi√©rarchie visuelle
1. **Labels** : `font-semibold` et `text-base`
2. **Descriptions champs** : `text-sm text-foreground-400`
3. **Messages d'aide** : `bg-background-200` avec ic√¥ne `<Info />`
4. **Compteurs s√©lection** : "‚úì N jour(s) s√©lectionn√©(s)"
5. **Warnings** : `text-[var(--warning)] bg-[var(--warning)]/10`
6. **Bordures Cards** : `border-2`
7. **Espacement** : `space-y-6` entre sections, `space-y-4` dans Cards

### Checklist formulaire
- [ ] 3 sections Cards : Identit√©, Fr√©quence, Options avanc√©es
- [ ] CardTitle + CardDescription
- [ ] Labels en `font-semibold` et `text-base`
- [ ] Pas d'emojis dans cat√©gories
- [ ] Boutons fr√©quence simplifi√©s
- [ ] Messages d'aide avec ic√¥ne Info
- [ ] Compteurs de s√©lection affich√©s
- [ ] Warnings jours > 28
- [ ] Accordion pour options avanc√©es (repli√©)
- [ ] Descriptions sous les champs

---

## ÔøΩüîÑ Extensions futures
*Section r√©serv√©e pour les ajouts futurs*
- Authentification OAuth (Google, GitHub)
- Int√©grations tierces (calendriers, fitness trackers)
- Analytics avanc√©es (graphiques de progression)
- Notifications push (rappels d'habitudes)
- Swipe interactions sur HabitCards (swipe left = delete, right = edit)
- Animations de confettis lors du level up (react-confetti)
- Export de donn√©es (CSV, PDF)
- Partage d'habitudes entre utilisateurs
- Templates d'habitudes pr√©d√©finies